# 职位搜索功能重构文档 - 从前端过滤到后端动态查询

## 重构日期
2026-02-11

## 重构目标

将"校招/职位搜索"功能从"前端过滤"重构为"后端数据库动态查询"，实现：
- 用户输入关键词、选择城市/行业/职位类型时，后端通过 MyBatis Plus 直接筛选数据
- 减少前端数据传输量
- 提高搜索性能和准确性

## 重构内容

### 1. 后端改造

#### 1.1 Service 层

**文件：** `JobService.java`

**修改前：**
```java
public interface JobService extends IService<Job> {
    List<Job> getAllJobs();
    List<Job> getJobsByCity(String city);
    List<Job> getJobsByIndustry(String industry);
    List<Job> getJobsByType(String jobType);
}
```

**修改后：**
```java
public interface JobService extends IService<Job> {
    /**
     * 动态搜索职位（支持关键词、城市、行业、职位类型筛选）
     */
    List<Job> searchJobs(String keyword, String city, String industry, String jobType);
}
```

**改进：**
- ✅ 统一搜索接口，支持多条件组合查询
- ✅ 移除冗余的单一条件查询方法

#### 1.2 Service 实现

**文件：** `JobServiceImpl.java`

**核心实现：**
```java
@Override
public List<Job> searchJobs(String keyword, String city, String industry, String jobType) {
    QueryWrapper<Job> wrapper = new QueryWrapper<>();

    // 只查询状态为 active 的职位
    wrapper.eq("status", "active");

    // 关键词搜索：标题或公司名包含关键词
    if (StringUtils.isNotBlank(keyword)) {
        wrapper.and(w -> w.like("title", keyword).or().like("company", keyword));
    }

    // 城市筛选（过滤掉"全部"、"全国"等特殊值）
    if (StringUtils.isNotBlank(city) &&
        !city.equals("全部") &&
        !city.equals("全国") &&
        !city.equals("不限")) {
        wrapper.eq("city", city);
    }

    // 行业筛选（过滤掉"全部"、"不限"等特殊值）
    if (StringUtils.isNotBlank(industry) &&
        !industry.equals("全部") &&
        !industry.equals("不限")) {
        wrapper.eq("industry", industry);
    }

    // 职位类型筛选（过滤掉"全部"等特殊值）
    if (StringUtils.isNotBlank(jobType) &&
        !jobType.equals("全部") &&
        !jobType.equals("不限")) {
        wrapper.eq("job_type", jobType);
    }

    // 按更新时间倒序排序
    wrapper.orderByDesc("updated_at");

    return list(wrapper);
}
```

**关键特性：**
1. ✅ 使用 `QueryWrapper` 构建动态查询
2. ✅ 关键词搜索支持标题和公司名
3. ✅ 过滤特殊值（"全部"、"不限"等）
4. ✅ 空指针保护（使用 `StringUtils.isNotBlank`）
5. ✅ 按更新时间倒序排序

#### 1.3 Controller 层

**文件：** `JobController.java`

**修改前：**
```java
@GetMapping("/list")
public Result<List<Job>> getAllJobs() {
    List<Job> jobs = jobService.getAllJobs();
    return Result.success(jobs);
}

@GetMapping("/city/{city}")
public Result<List<Job>> getJobsByCity(@PathVariable String city) {
    // ...
}

@GetMapping("/industry/{industry}")
public Result<List<Job>> getJobsByIndustry(@PathVariable String industry) {
    // ...
}

@GetMapping("/type/{jobType}")
public Result<List<Job>> getJobsByType(@PathVariable String jobType) {
    // ...
}
```

**修改后：**
```java
/**
 * 动态搜索职位列表（支持关键词、城市、行业、职位类型筛选）
 */
@GetMapping("/list")
public Result<List<Job>> list(
        @RequestParam(required = false) String keyword,
        @RequestParam(required = false) String city,
        @RequestParam(required = false) String industry,
        @RequestParam(required = false) String jobType) {
    List<Job> jobs = jobService.searchJobs(keyword, city, industry, jobType);
    return Result.success(jobs);
}

// 旧接口标记为 @Deprecated，保留用于兼容性
@Deprecated
@GetMapping("/city/{city}")
public Result<List<Job>> getJobsByCity(@PathVariable String city) {
    List<Job> jobs = jobService.searchJobs(null, city, null, null);
    return Result.success(jobs);
}
```

**改进：**
- ✅ 统一的 `/list` 接口支持多参数查询
- ✅ 所有参数都是可选的（`required = false`）
- ✅ 旧接口标记为 `@Deprecated`，保留兼容性

### 2. 前端改造

#### 2.1 API 层

**文件：** `utils/api.js`

**修改前：**
```javascript
function getJobList() {
  return get('/job/list');
}
```

**修改后：**
```javascript
/**
 * 获取职位列表（支持动态搜索）
 * @param {Object} params - 查询参数
 * @param {string} params.keyword - 关键词（可选）
 * @param {string} params.city - 城市（可选）
 * @param {string} params.industry - 行业（可选）
 * @param {string} params.jobType - 职位类型（可选）
 */
function getJobList(params) {
  return get('/job/list', params);
}
```

**改进：**
- ✅ 支持传递查询参数对象
- ✅ 清晰的 JSDoc 注释

#### 2.2 页面逻辑

**文件：** `pages/campus/campus.js`

**修改前：**
```javascript
loadJobsFromBackend() {
  api.getJobList()
    .then(res => {
      // 加载所有数据
      const jobs = res.data.map(job => ({...}));

      // 保存到 companiesByTab
      this.setData({
        companiesByTab: { 0: jobs, 1: [], 2: [] }
      }, () => {
        // 前端筛选
        this.refreshCompanies();
      });
    });
}

refreshCompanies() {
  // 复杂的前端筛选逻辑
  const source = companiesByTab[active] || [];
  const list = source.filter((c) => {
    // 关键词筛选
    // 行业筛选
    // 城市筛选
    // ...
  });
  this.setData({ companies: list });
}
```

**修改后：**
```javascript
loadJobsFromBackend() {
  // 构建查询参数
  const params = {};

  // 关键词搜索
  const keyword = (this.data.searchQuery || '').trim();
  if (keyword) {
    params.keyword = keyword;
  }

  // 城市筛选（取第一个选中的城市）
  const selectedCities = this.data.selectedCities || [];
  if (selectedCities.length > 0) {
    const city = selectedCities[0];
    if (city && city !== '全部' && city !== '全国' && city !== '不限') {
      params.city = city;
    }
  }

  // 行业筛选（取第一个选中的行业）
  const selectedIndustries = this.data.selectedIndustries || [];
  if (selectedIndustries.length > 0) {
    const industry = selectedIndustries[0];
    if (industry && industry !== '全部' && industry !== '不限') {
      params.industry = industry;
    }
  }

  // 职位类型筛选（取第一个选中的职位类型）
  const selectedPositions = this.data.selectedPositions || [];
  if (selectedPositions.length > 0) {
    const jobType = selectedPositions[0];
    if (jobType && jobType !== '全部' && jobType !== '不限') {
      params.jobType = jobType;
    }
  }

  wx.showLoading({ title: '加载中...' });

  api.getJobList(params)
    .then(res => {
      wx.hideLoading();
      if (res.code === 200 && res.data) {
        // 直接设置为当前显示的列表
        const jobs = res.data.map(job => ({
          id: job.id,
          name: job.company,
          logo: '/images/company1.jpg',
          tags: [job.industry, job.jobType, job.city].filter(Boolean),
          industry: job.industry,
          position: job.title,
          city: job.city,
          description: `${job.title} | ${job.salaryRange || '面议'} | ${job.educationRequired || ''}`,
          jobCount: 1,
          jobData: job
        }));

        this.setData({ companies: jobs });
      }
    });
}

// refreshCompanies 方法已废弃
refreshCompanies() {
  console.warn('refreshCompanies 方法已废弃，请使用 loadJobsFromBackend');
}
```

**改进：**
1. ✅ 移除前端筛选逻辑
2. ✅ 直接将查询参数传递给后端
3. ✅ 过滤特殊值（"全部"、"不限"等）
4. ✅ 简化数据流：后端 → 前端显示

#### 2.3 搜索和筛选事件

**修改前：**
```javascript
onSearchConfirm(e) {
  const value = e.detail.value;
  this.setData({ searchQuery: value }, () => {
    this.refreshCompanies(); // 前端筛选
  });
}

onShow() {
  this.syncSelectedCities();
  this.syncSelectedIndustries();
  this.syncSelectedPositions();
  this.loadJobsFromBackend(); // 加载所有数据
}
```

**修改后：**
```javascript
onSearchConfirm(e) {
  const value = e.detail.value;
  this.setData({ searchQuery: value }, () => {
    this.loadJobsFromBackend(); // 触发后端搜索
  });
}

onShow() {
  this.syncSelectedCities();
  this.syncSelectedIndustries();
  this.syncSelectedPositions();
  this.loadJobsFromBackend(); // 触发后端搜索
}
```

**改进：**
- ✅ 所有筛选操作都触发后端查询
- ✅ 用户返回页面时自动刷新结果

## 数据流对比

### 重构前（前端过滤）

```
用户打开页面
    ↓
加载所有职位数据（可能很大）
    ↓
前端保存到 companiesByTab
    ↓
用户输入关键词/选择筛选条件
    ↓
前端遍历所有数据进行筛选
    ↓
显示筛选结果
```

**问题：**
- ❌ 加载所有数据，浪费带宽
- ❌ 前端筛选逻辑复杂
- ❌ 数据量大时性能差
- ❌ 无法利用数据库索引

### 重构后（后端动态查询）

```
用户打开页面
    ↓
构建查询参数（keyword, city, industry, jobType）
    ↓
发送到后端
    ↓
后端使用 MyBatis Plus 动态查询
    ↓
返回筛选后的数据
    ↓
前端直接显示
```

**优势：**
- ✅ 只传输需要的数据
- ✅ 利用数据库索引，查询快
- ✅ 前端逻辑简单
- ✅ 支持大数据量

## API 接口文档

### 职位搜索接口

**接口地址：** `GET /api/job/list`

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| keyword | String | 否 | 关键词（搜索标题和公司名） | "前端" |
| city | String | 否 | 城市 | "北京" |
| industry | String | 否 | 行业 | "互联网" |
| jobType | String | 否 | 职位类型 | "技术" |

**请求示例：**

```
# 搜索关键词
GET /api/job/list?keyword=前端

# 按城市筛选
GET /api/job/list?city=北京

# 组合查询
GET /api/job/list?keyword=Java&city=上海&industry=互联网

# 获取所有职位
GET /api/job/list
```

**响应示例：**

```json
{
  "code": 200,
  "message": "success",
  "data": [
    {
      "id": 1,
      "title": "前端开发工程师",
      "company": "阿里巴巴",
      "city": "杭州",
      "salaryRange": "15k-30k",
      "educationRequired": "本科",
      "experienceRequired": "1-3年",
      "jobType": "技术",
      "industry": "互联网",
      "description": "...",
      "requirements": "...",
      "benefits": "...",
      "status": "active",
      "createdAt": "2024-01-01T00:00:00",
      "updatedAt": "2024-01-01T00:00:00"
    }
  ]
}
```

## SQL 查询示例

### 场景 1：关键词搜索

**前端请求：**
```
GET /api/job/list?keyword=Java
```

**生成的 SQL：**
```sql
SELECT * FROM job
WHERE status = 'active'
  AND (title LIKE '%Java%' OR company LIKE '%Java%')
ORDER BY updated_at DESC
```

### 场景 2：城市筛选

**前端请求：**
```
GET /api/job/list?city=北京
```

**生成的 SQL：**
```sql
SELECT * FROM job
WHERE status = 'active'
  AND city = '北京'
ORDER BY updated_at DESC
```

### 场景 3：组合查询

**前端请求：**
```
GET /api/job/list?keyword=前端&city=上海&industry=互联网
```

**生成的 SQL：**
```sql
SELECT * FROM job
WHERE status = 'active'
  AND (title LIKE '%前端%' OR company LIKE '%前端%')
  AND city = '上海'
  AND industry = '互联网'
ORDER BY updated_at DESC
```

### 场景 4：特殊值过滤

**前端请求：**
```
GET /api/job/list?city=全部&industry=不限
```

**生成的 SQL：**
```sql
SELECT * FROM job
WHERE status = 'active'
ORDER BY updated_at DESC
```

**说明：** "全部"、"不限"等特殊值被过滤掉，不会生成无效的 WHERE 条件。

## 性能优化

### 1. 数据库索引

建议添加以下索引：

```sql
-- 状态索引（必须）
CREATE INDEX idx_status ON job(status);

-- 城市索引
CREATE INDEX idx_city ON job(city);

-- 行业索引
CREATE INDEX idx_industry ON job(industry);

-- 职位类型索引
CREATE INDEX idx_job_type ON job(job_type);

-- 更新时间索引（用于排序）
CREATE INDEX idx_updated_at ON job(updated_at DESC);

-- 组合索引（常用查询组合）
CREATE INDEX idx_status_city_industry ON job(status, city, industry);
```

### 2. 查询优化

**优化前：**
```java
// 每次都查询所有字段
wrapper.eq("status", "active");
return list(wrapper);
```

**优化后（可选）：**
```java
// 只查询需要的字段
wrapper.eq("status", "active");
wrapper.select("id", "title", "company", "city", "salary_range",
               "education_required", "job_type", "industry");
return list(wrapper);
```

### 3. 分页支持（未来扩展）

```java
public IPage<Job> searchJobs(String keyword, String city, String industry,
                              String jobType, int page, int size) {
    QueryWrapper<Job> wrapper = new QueryWrapper<>();
    // ... 构建查询条件

    Page<Job> pageParam = new Page<>(page, size);
    return page(pageParam, wrapper);
}
```

## 测试步骤

### 1. 测试关键词搜索

```
步骤：
1. 打开校招页面
2. 在搜索框输入"前端"
3. 点击搜索或按回车

预期结果：
✅ 显示标题或公司名包含"前端"的职位
✅ 加载速度快
✅ 结果准确
```

### 2. 测试城市筛选

```
步骤：
1. 打开校招页面
2. 点击城市筛选
3. 选择"北京"
4. 返回列表页

预期结果：
✅ 只显示北京的职位
✅ 自动刷新列表
```

### 3. 测试组合查询

```
步骤：
1. 输入关键词"Java"
2. 选择城市"上海"
3. 选择行业"互联网"

预期结果：
✅ 显示符合所有条件的职位
✅ 结果准确
```

### 4. 测试特殊值

```
步骤：
1. 选择城市"全部"
2. 选择行业"不限"

预期结果：
✅ 显示所有职位
✅ 不会出现查询错误
```

### 5. 测试空结果

```
步骤：
1. 输入不存在的关键词"XXXXXX"

预期结果：
✅ 显示空列表
✅ 提示"暂无数据"
```

## 注意事项

### 1. 特殊值处理

**前端：**
```javascript
// 过滤特殊值
if (city && city !== '全部' && city !== '全国' && city !== '不限') {
  params.city = city;
}
```

**后端：**
```java
// 双重保护
if (StringUtils.isNotBlank(city) &&
    !city.equals("全部") &&
    !city.equals("全国") &&
    !city.equals("不限")) {
    wrapper.eq("city", city);
}
```

### 2. 空指针保护

```java
// 使用 StringUtils.isNotBlank 而不是 != null
if (StringUtils.isNotBlank(keyword)) {
    wrapper.and(w -> w.like("title", keyword).or().like("company", keyword));
}
```

### 3. 字段映射

**实体类字段（驼峰）：**
```java
private String jobType;
```

**数据库字段（下划线）：**
```sql
job_type
```

**MyBatis Plus 自动处理：**
```java
wrapper.eq("job_type", jobType); // 正确
// 或
wrapper.eq("jobType", jobType);  // 也正确（自动转换）
```

### 4. SQL 注入防护

MyBatis Plus 的 `QueryWrapper` 自动使用预编译语句，防止 SQL 注入：

```java
// 安全的
wrapper.like("title", keyword);

// 生成的 SQL
// WHERE title LIKE ?
// 参数: %keyword%
```

## 总结

通过这次重构，我们实现了：

✅ **后端动态查询**：使用 MyBatis Plus 构建灵活的查询条件
✅ **性能提升**：只传输需要的数据，利用数据库索引
✅ **代码简化**：移除复杂的前端筛选逻辑
✅ **可扩展性**：易于添加新的筛选条件
✅ **用户体验**：搜索响应快，结果准确

现在职位搜索功能完全由后端数据库驱动，前端只负责展示结果。
